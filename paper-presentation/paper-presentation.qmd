---
title: "Team size and composition in home health care"
author: "René Bekker, Yoram Clapper, Witek ten Hove and Dennis Moeke"
format:
  revealjs:
    navigation-mode: vertical
    theme: [default, custom.scss]
bibliography: references.bib
execute:
  output: true
jupyter: python3
---

# Decision problem

![From: @grieco2021operational](decisionproblems.png)

# Principles

[1 - Care demand]{style="color: red;"}

2 - Travel time

[3 - Effective capacity]{style="color: red;"}

[4 - Team composition]{style="color: red;"}

5 - Contract type

[6 - Communication and management]{style="color: red;"}

# Data understanding

# Data preparation

# Modeling

# Principle 1: Care Demand

::: columns
::: {.column width="50%"}
Demand per week [$N$]{style="color: red;"} is generated by:

-   Arrival rates [$a$]{style="color: red;"}: number of new cases per week
-   Length of stays [$s$]{style="color: red;"}: number of weeks per case
-   Amount of care [$g$]{style="color: red;"}: hours per case per week
:::

::: {.column width="50%"}
![](images/demand.png)
:::
:::

## Principle 1: Care Demand

For some grade of service [$\gamma$]{style="color: red;"}, the required weekly capacity [$C$]{style="color: red;"} is $$C = \rho + \gamma z \rho$$

where [$\rho$]{style="color: red;"} $= m_am_sm_g$ is the average demand, and [$z$]{style="color: red;"} is the peakedness given by $$z = \frac{\sigma_g^2}{m_g} + m_g + m_g(1−G_s)(\frac{\sigma_a^2}{m_a}-1)$$.

## Principle 1: Care Demand

::: columns
::: {.column width="40%"}
Hence, the utilization of the capacity [$C$]{style="color: red;"} is $$\frac{\mathbb{E}[N]}{C} = \frac{1}{1 + \frac{\gamma\sqrt{z}}{\sqrt{\rho}}} $$
:::

::: {.column width="60%"}
```{python}
#------------------------------------------------------------------------------
# Principle 1: care demand
#------------------------------------------------------------------------------

# generates image of utility vs average weekly demand
# gamma: grade of service, typically between [0.5, 2.]
# z: variance-to-mean ratio (variance weekly demand / mean weekly demand)
# max_rho: upper limit of x-axis (maximum weekly demand in hours to observe)
# min_rho: lower limit of x-axis (maximum weekly demand in hours to observe)
import matplotlib.pyplot as plt 
import numpy as np 
import scipy.integrate as integrate 
from scipy.stats import norm
import networkx as nx

def plot_care_demand(gamma,idx,z,d,min_rho,max_rho):
    fig, ax = plt.subplots(figsize=(9.6,7.2))
    ax.set_xlabel('Average weekly demand in hours',size=12)
    ax.set_ylabel('Utilization of capacity',size=12)
    
    rho = np.arange(min_rho, max_rho)
    N = len(idx)
    color = ['blue','orange','green']
    for i in range(N):
        nr = idx[i]
        z_i = z[i]
        d_i = d[i]
        u_i = 1 / (1 + gamma*np.sqrt(z_i/rho))
        c_i = color[i]
        ax.plot(rho,u_i,color=c_i,label='Team '+str(nr),linestyle='solid')
    
        xlim = ax.get_xlim()
        ylim = ax.get_ylim()
        ax.set_xlim(xlim)
        ax.set_ylim(ylim[0],1)
        
        pin_u = 1 / (1 + gamma*np.sqrt(z_i/d_i))
        ax.hlines(pin_u,xmin=xlim[0],xmax=d_i,color='grey',linestyle='dashed')
        ax.vlines(d_i,ymin=ylim[0],ymax=pin_u,color='grey',linestyle='dashed')
        ax.plot(d_i, pin_u,color=c_i,marker='s')
    
    ax.legend()
    plt.show()  # This will display the plot
    plt.close()

plot_care_demand(gamma=1,idx=[5,32,29],z=[6.99,9.01,18.49],d=[132.30,370.87,231.59],min_rho=50,max_rho=1000)
```
:::
:::

## Principle 1: Care Demand

*The buffer capacity required to handle demand variability decreases with scale, but the possible reduction becomes smaller as the scale increases.*

# Principle 3: Effective capacity

![](images/workingtime.png)

## Principle 3: Effective capacity

Let M be the total number of scheduled care workers during some period [$T$]{style="color: red;"}, and let [$p$]{style="color: red;"} be the probability that the care worker is present.

The number of care workers present [$\tilde{M}$]{style="color: red;"} then follows a Binomial($M$, $p$) distribution. Consequently, the properties of the effective capacity

[$P$]{style="color: red;"} $= \frac{\tilde{M}}{M}$

follow directly from this observation.

## Principle 3: Effective capacity

For $k\in [0,1]$, the probability that the effective capacity [$P$]{style="color: red;"} is at most [$k$]{style="color: red;"} equals

$$\mathbb{P}(P \le k) = \mathbb{P}(\tilde M \le k M)
 = \frac{B(kM+1,(1-k)M,p)}{B(kM+1,(1-k)M)}$$ with $B(x,y,p) = \int_p^1 t^{x-1} (1-t)^{y-1} {\rm d}t$ the incomplete Beta function and $B(x,y) = B(x,y,0)$.

## Principle 3: Effective capacity

*Small teams are more prone to lower levels of effective capacity than large teams as a result of variability in leave of absence and sick leave, whereas the differences between larger teams become smaller.*

```{python}
#------------------------------------------------------------------------------
# Principle 3: productivity
#------------------------------------------------------------------------------
# calculates cdf of productivity: Pr(P <= x)
# M: total scheduled workers
# p: probability a worker is present on scheduled moment
def productivity_cdf(x,M,p):
    
    # functions to calculate incomplete beta function
    def poly(t,x,y) : return t**(x-1) * (1-t)**(y-1)
    def betainc(x,y,pr) : return integrate.quad(lambda t : poly(t,x,y), pr, 1)
    
    cdf = betainc(x*M + 1, (1 - x)*M, p)[0] / betainc(x*M + 1, (1 - x)*M, 0)[0]
    
    return cdf

# generates image of productivity cdf vs total scheduled workers
# targets(list): all (cdf) values to be evaluated: i.e. all x's to Pr(P <= x)
# p: probability a worker is present on scheduled moment
# max_M: upper limit of x-axis (maximum scheduled workers)
# min_M: lower limit of x-axis (minimum scheduled workers) 
def plot_productivity(targets,p,min_M,max_M,pinned_size):
    fig, ax = plt.subplots(figsize=(8,5))
    M = np.arange(min_M, max_M)
    
    if type(targets) == float or type(targets) == int : targets = [targets]
    for x in targets:
        label = 'k = '+str(x)
        cdf = np.array([productivity_cdf(x,m,p) for m in M])
        if x == 0.6:
            xcdf = cdf.copy()
        ax.plot(M,cdf,label=label)
        
    xlim = ax.get_xlim()
    ylim = ax.get_ylim()
    ax.set_xlim(xlim)
    ax.set_ylim(ylim)
        
    pinned_cdf = xcdf[pinned_size-1]
    ax.hlines(pinned_cdf,xmin=xlim[0],xmax=pinned_size,color='grey',linestyles='dashed')
    ax.vlines(pinned_size,ymin=ylim[0],ymax=pinned_cdf,color='grey',linestyles='dashed')
    ax.plot(pinned_size, pinned_cdf,color='orange',marker='o')
    
    pinned_size_db = 19
    pinned_cdf = xcdf[pinned_size_db-1]
    ax.hlines(pinned_cdf,xmin=xlim[0],xmax=pinned_size_db,color='grey',linestyles='dashed')
    ax.vlines(pinned_size_db,ymin=ylim[0],ymax=pinned_cdf,color='grey',linestyles='dashed')
    ax.plot(pinned_size_db, pinned_cdf,color='orange',marker='o')
    
    #ax.set_title('Productivity as a function of team size',size=16)
    ax.set_xlabel('Team size',size=12)
    ax.set_ylabel('$Pr(P \leq k)$',size=12)
    ax.legend()
    
    plt.show()  # This will display the plot
    plt.close()

plot_productivity([0.5,0.6,0.7], p=0.79, min_M=1, max_M=40, pinned_size = 7)
```

# Principle 4: Team composition

| Level | Qualification | Type of tasks | \% of planned care |
|------:|---------------|---------------|-------------------:|
|     1 | PV niveau 2+  | Personal Care |                67% |
|     2 | PV niveau 3   | Personal Care |                 9% |
|     3 | VP niveau 3   | Nursing       |                24% |

## Principle 4: Team composition

![](images/3a.png)

## Principle 4: Team composition

::: columns
::: {.column width="75%"}
```{python}
#------------------------------------------------------------------------------
# Principle 4: team composition
#------------------------------------------------------------------------------

# computes the expected excess for available capacity under assumption of normal distribution
# cap (float): available capacity
# mean: mean weekly demand (normal distribution)
# std: standard deviation of weekly demand (normal distribution)
def expected_excess(cap,mean,std):
    c = (cap-mean)/std
    s = std
    return s*c*norm.cdf(c) + (s/np.sqrt(2))*np.exp(-0.5*c**2)

# returns list of optimal capacity per qualification level obtained recursively
# maxQ (int): highest qualification level (ranked by integer values)
# mu (list): mean weekly demand per qualification level
# std (list): standard deviation of weekly demand per qualification level
# z (float): service level (based on normal distribution)
# NOTE: all lists need to be ordered by rank of qualification levels
def get_capacity(maxQ,mu,sigma,z):
    k = maxQ + 0
    capacity = np.zeros(maxQ)
    excess = np.zeros(maxQ)
    while k > 0:
        m_k = mu[k-1]
        s_k = sigma[k-1]
        e_k = excess[k-1]
            
        v = m_k + z*s_k - e_k
        if v > 0:
            capacity[k-1] = v
            
        k -= 1
        val = np.sum(capacity[k:] - excess[k:])
        mean = np.sum(mu[k:])
        std = np.sqrt(np.sum(sigma[k:]**2))
        excess[k-1] = expected_excess(val,mean,std)
    return capacity

# generates image of optimal capacity distribution over qualification level
# maxQ (int): highest qualification level (ranked by integer values)
# mu (list): mean weekly demand per qualification level
# sigma (list): standard deviation of weekly demand per qualification level
# z (float): service level (based on normal distribution)
# max_rate: upper limit x-axis (scaling by arrival rate)
# min_rate: lower limit x-axis (scaling by arrival rate)
def plot_optimal_cap_on_qlevel(maxQ,mu,sigma,z,min_rate,max_rate):
    fig, ax = plt.subplots(figsize=(9.6,7.2))
    mu = np.array(mu)
    sigma = np.array(sigma)
    
    rate = np.arange(min_rate,max_rate+0.1,0.1)
    norm_cap_matrix = np.zeros((len(rate),maxQ))
    for i, m in enumerate(rate):
        mu_scaled = m * mu
        sigma_scaled = np.sqrt(m) * sigma
        capacity = get_capacity(maxQ,mu_scaled,sigma_scaled,z)
        cap_sum = np.sum(capacity)
        norm_cap_matrix[i] = capacity/cap_sum
     
    mean_norm = mu / np.sum(mu)
    color = {0:'blue',1:'red',2:'green',3:'orange'}
    label = {0:'PV niveau 2+',1:'PV niveau 3',2:'VP niveau 3'}
    for k in np.arange(maxQ):
        capx = norm_cap_matrix.T[k]
        meanx = np.array([mean_norm[k] for _ in range(len(rate))])
        ax.plot(rate,capx,c=color[k],label=label[k])
        ax.plot(rate,meanx,c=color[k],linestyle='dashed')
    ax.legend()
    #ax.set_title('Optimal distribution of capacity over qualification levels',size=16)
    ax.set_xlabel('$m_a$ (scaling factor)',size=12)
    ax.set_ylabel('Capacity ratio',size=12)
    
    limx = ax.get_ylim()
    ax.vlines(1, ymin=limx[0], ymax=limx[1], color='grey', linestyles='dashed')
    # ax.vlines(2, ymin=limx[0], ymax=limx[1], color='grey', linestyles='dashed')
    
    plt.show()  # This will display the plot
    plt.close()

plot_optimal_cap_on_qlevel(maxQ=3, mu=[49.16, 20, 63.13], sigma=[12.85, 9.29, 17.92], z=1, min_rate=0.1, max_rate=5)
```
:::

::: {.column width="25%"}
![](images/3acrop.png)
:::
:::

# Principle 6: Communication and management

::: columns
::: {.column width="60%"}
Let [$M$]{style="color: red;"} be the number of members of a team. Then there are $$\frac{M(M-1)}{2}$$ potential interactions between team members. In terms of complexity the number of interactions between a team of size [$M$]{style="color: red;"} equals $O(M^2)$
:::

::: {.column width="40%"}
```{python}
def plot_complete_graph(M):
    plt.clf()
    # Create a complete graph with M nodes
    G = nx.complete_graph(M)
    
    # Draw the graph
    pos = nx.spring_layout(G)  # positions for all nodes
    nx.draw_networkx_nodes(G, pos, node_size=700, node_color="tomato")
    nx.draw_networkx_edges(G, pos, width=1.0, alpha=0.5)
    nx.draw_networkx_labels(G, pos, font_size=20, font_color="white")
    
    plt.title("Complete Graph with {} nodes".format(M))
    plt.show()
    plt.close()

# Test the function
plot_complete_graph(5)
```
:::
:::

## Principle 6: Communication and management

```{python}
import matplotlib.pyplot as plt
import networkx as nx

def plot_graph(N, k, M):
    plt.clf()
    G = nx.Graph()
    
    if N == 0:
        # Create a complete graph with M nodes
        G = nx.complete_graph(M)
        
    elif N == 1:
        central_node = 0
        G.add_node(central_node)
        
        nodes_per_graph = M // k
        for i in range(k):
            # Create a complete graph for each k
            start = i * nodes_per_graph + 1
            end = start + nodes_per_graph
            subgraph = nx.complete_graph(range(start, end))
            
            # Add the subgraph to the main graph
            G = nx.union(G, subgraph)
            
            # Connect the central node to one node in each subgraph
            G.add_edge(central_node, start)
    
    # Compute the number of nodes and edges
    total_nodes = G.number_of_nodes()
    total_edges = G.number_of_edges()
    
    # Draw the graph
    pos = nx.spring_layout(G)
    nx.draw_networkx_nodes(G, pos, node_color="tomato")
    nx.draw_networkx_edges(G, pos)
    nx.draw_networkx_labels(G, pos, font_color="white")
    
    # Set the title
    plt.title(f"Graph with {total_nodes} nodes and {total_edges} edges")
    
    plt.show()
    plt.close()
```

::: columns
::: {.column width="50%"}
```{python}
plot_graph(0, 3, 12);  # Complete graph with 12 nodes
```
:::

::: {.column width="50%"}
```{python}
plot_graph(1, 3, 12);  # 3 complete graphs with 2 nodes each connected to a central node
```
:::
:::

## Principle 6


*The complexity of the number of interactions for a team of size [$M$]{style="color: red;"} is $O(M^2)$. By splitting the team into [$k$]{style="color: red;"} sub-teams, managed by one mediator, the number of interactions can be reduced by a factor [$k$]{style="color: red;"} as [$M$]{style="color: red;"} grows large.*


```{python}
#------------------------------------------------------------------------------
# Principle 6: communication and management
#------------------------------------------------------------------------------

# generates image of number of interactions per team size under splitted teams
# team_splits: maximum number of times a team can be (equally) splitted
# max_team_size: upper limit x-axis (largest team size to observe)
def plot_interactions(team_splits,max_team_size, pinned_size):
    fig, ax = plt.subplots()
    
    sizes = np.arange(max_team_size+1)
    for k in range(1,team_splits+1):
        inter = 0.5 * sizes * (1 + (1/k) * sizes)
        if k == 1:
            ax.plot(sizes,inter,label='Complete team')
            
            xlim = ax.get_xlim()
            ylim = ax.get_ylim()
            ax.set_xlim(xlim)
            ax.set_ylim(ylim)
            
            pinned_target = 0.5 * pinned_size * (1 + (1/k) * pinned_size)
            ax.hlines(pinned_target, xmin=xlim[0], xmax=pinned_size, color='grey', linestyles='dashed')
            ax.vlines(pinned_size, ymin=ylim[0], ymax=pinned_target, color='grey', linestyles='dashed')
            ax.plot(pinned_size, pinned_target, 'bo')
            
            pinned_size_db = 19
            pinned_target_db = 0.5 * pinned_size_db * (1 + (1/k) * pinned_size_db)
            ax.hlines(pinned_target_db, xmin=xlim[0], xmax=pinned_size_db, color='grey', linestyles='dashed')
            ax.vlines(pinned_size_db, ymin=ylim[0], ymax=pinned_target_db, color='grey', linestyles='dashed')
            ax.plot(pinned_size_db, pinned_target_db, 'bo')
            
        else:
            ax.plot(sizes,inter,label='Team split in '+str(k))
            
            if k == 2:
                xlim = ax.get_xlim()
                ylim = ax.get_ylim()
                ax.set_xlim(xlim)
                ax.set_ylim(ylim)
                
                pinned_target = 0.5 * pinned_size * (1 + (1/k) * pinned_size)
                ax.hlines(pinned_target, xmin=xlim[0], xmax=pinned_size, color='grey', linestyles='dashed')
                ax.vlines(pinned_size, ymin=ylim[0], ymax=pinned_target, color='grey', linestyles='dashed')
                ax.plot(pinned_size, pinned_target, color = 'orange', marker = 'o')
                
                pinned_size_db = 19
                pinned_target_db = 0.5 * pinned_size_db * (1 + (1/k) * pinned_size_db)
                ax.hlines(pinned_target_db, xmin=xlim[0], xmax=pinned_size_db, color='grey', linestyles='dashed')
                ax.vlines(pinned_size_db, ymin=ylim[0], ymax=pinned_target_db, color='grey', linestyles='dashed')
                ax.plot(pinned_size_db, pinned_target_db, color = 'orange', marker = 'o')

    ax.legend()
    plt.xticks(range(0,max_team_size+1,5))
    ax.set_xlabel('Team size',size=12)
    ax.set_ylabel('Number of interactions',size=12)
    
    plt.show()  # This will display the plot
    plt.close()
  
plot_interactions(team_splits=4, max_team_size=20, pinned_size=7);
```


# Discussion

When you click the **Render** button a presentation will be generated that includes both content and the output of embedded code. You can embed code like this:

# Conclusion

When you click the **Render** button a presentation will be generated that includes both content and the output of embedded code. You can embed code like this:

# References {.unnumbered}

::: {#refs}
:::
